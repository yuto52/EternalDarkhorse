<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R3_B1F_EH</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>
    <input id="date" type="date" min="2023-04-10" max="2024-07-13">
    <button id="plotButton">過去/予測データを表示</button>
    
    <canvas id="myChart1" width="400" height="200"></canvas>
    <canvas id="myChart2" width="400" height="200"></canvas>
    <canvas id="myChart3" width="400" height="200"></canvas>
    
    <script>
        let myChart1 = null;
        let myChart2 = null;
        let myChart3 = null;

        const sensorDataUrl = '/mnt/data/SensorData.csv';  // 実測値のデータURL
        const forecastUrls = [
            'https://example.com/csv1.csv',  // 予測データのCSVファイル1のURL
            'https://example.com/csv2.csv',  // 予測データのCSVファイル2のURL
            'https://example.com/csv3.csv'   // 予測データのCSVファイル3のURL
        ];

        document.getElementById('plotButton').addEventListener('click', async function() {
            const dateInput = document.getElementById('date').value;
            
            if (!dateInput) {
                alert('日付を選択してください。');
                return;
            }

            // 実測値のデータを取得
            const sensorData = await fetchCSV(sensorDataUrl);
            const forecastData = await Promise.all(forecastUrls.map(url => fetchCSV(url)));

            plotData(sensorData, forecastData[0], dateInput, 'myChart1', myChart1, chart => myChart1 = chart, 400, 1200, 'CO2 [ppm]', 'co2');
            plotData(sensorData, forecastData[1], dateInput, 'myChart2', myChart2, chart => myChart2 = chart, 10, 50, '気温 [℃]', 'temperature');
            plotData(sensorData, forecastData[2], dateInput, 'myChart3', myChart3, chart => myChart3 = chart, 0, 100, '湿度 [%]', 'humidity');
        });

        async function fetchCSV(url) {
            const response = await fetch(url);
            const text = await response.text();
            return parseCSV(text);
        }

        function parseCSV(csv) {
            const lines = csv.split('\n');
            const result = [];
            const headers = lines[0].split(',');

            for (let i = 1; i < lines.length; i++) {
                const obj = {};
                const currentline = lines[i].split(',');

                for (let j = 0; j < headers.length; j++) {
                    obj[headers[j]] = currentline[j];
                }
                result.push(obj);
            }
            return result;
        }

        function plotData(sensorData, forecastData, date, canvasId, existingChart, updateChartRef, yMin, yMax, label, dataKey) {
            const dateObj = new Date(date);
            const endOfJune = new Date('2024-06-30');

            let dataToPlot;

            if (dateObj <= endOfJune) {
                dataToPlot = sensorData.filter(row => row.ds.startsWith(date));
            } else {
                dataToPlot = forecastData.filter(row => row.ds.startsWith(date));
            }

            if (dataToPlot.length === 0) {
                alert(`指定された日付のデータがありません (${canvasId})。`);
                return;
            }

            const labels = dataToPlot.map(row => row.ds);
            const values = dataToPlot.map(row => parseFloat(row[dataKey]));

            const ctx = document.getElementById(canvasId).getContext('2d');
            
            // 既存のチャートがあれば破棄
            if (existingChart) {
                existingChart.destroy();
            }

            const newChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: values,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            min: yMin,
                            max: yMax
                        }
                    }
                }
            });

            // チャート参照を更新
            updateChartRef(newChart);
        }
    </script>
</body>
</html>
